\documentclass{article}

\usepackage{listings}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{array}
\usepackage{txfonts}
\usepackage{syntax}
\usepackage{titlesec}

\usepackage[T1]{fontenc}
\usepackage{upquote}
\usepackage[dvipsnames]{xcolor}
\usepackage{hyperref}
\usepackage{hyphenat}
\usepackage{scrextend}

\usepackage{lib/bcprules}

\usepackage[USenglish]{babel}
\usepackage[useregional]{datetime2}

\author{Arthur Giesel Vedana}
\title{V Syntax and Documentation}
\begin{document}

\maketitle

\tableofcontents
\newpage

\section{Abstract Syntax Tree}

\subsection{Terms}

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}>{$}r<{$}}
e &::= &n\\
  &| &x\\
  &| &(e_1, \; \dots \; e_n) & (n\geq2)\\
  &| &\{l_1: e_1, \; \dots \; l_n: e_n\} & (n\geq1)\\
  &| &\#path\\
  &| &stack \; e_1 \; e_2 \\
  &| &distort \; e_1 \; e_2 \; e_3\\
  &| &get \; e_1 \; e_2\\
  &| &set \; e_1 \; e_2 \; e_3\\
  &| &\texttt{let} \; p = e_1 \; \texttt{in} \; e_2\\
  &| &\texttt{fn} \; p \Rightarrow e\\
  &| &e_1 \; e_2\\
  &| &raise\\
  &| &\texttt{match} \; e \; \texttt{with} \; match_1, ... \; match_n& (n\geq1)\\
  \\
path &::= &l\\
  &| &path_1 \; . \; path_2\\
  &| &(e_1, \; \dots \; e_n) & (n\geq2)\\
  &| &path \; [e_1, \; e_2] \\
  \\
match &::= &p \rightarrow e\\
  &| &p \; \texttt{when} \; e_1 \rightarrow e_2\\
  \\
  l &::= & \{l_1, l_2, ...\}\\
p &::= &x\\
  &| &\_\\
  &| &n\\
  &| &(p_1, \; \dots \; p_n) & (n\geq2)\\
  &| &\{l_1: p_1, \; \dots \; l_n: p_n\} & (n\geq1)\\
  &| &\{l_1: p_1, \; \dots \; l_n: p_n, \dots\} & (\text{partial record}, n\geq1)\\
  \\
  x &::= &\{ x_0, x_1, \ldots \}\\
  \\
  n &::= &\mathbb{Z}\\
\end{tabular}}

\subsection{Types and Traits}

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}>{$}r<{$}}
T &::= &\mbox{Int}\\
&| &T_1 \rightarrow T_2\\
&| &(T_1, \; \dots \; T_n) & (n\geq2)\\
&| &\{l_1: T_1, \; \dots \; l_n: T_n\} & (n\geq1)\\
&| &\#(T_1 \rightarrow T_2) & Accessor\\
&| &X^{Traits}\\
\\
X &::= &{X_1, X_2, ...}\\
\\
Traits &::= &\varnothing\\
&| &\{Trait\} \cup Traits\\
\\
Trait &::= &\{l: Type\} & (Record Label)\\
\end{tabular}}

\paragraph{Record Label}
A record label trait specifies a type $T$ that a record must have associated to a label $l$.
No bounds are placed on the size of the record, since records are unordered sets of label-type pairs.

To define the set of types that belong to a record label $\{l: T\}$, the following rules are used:

\medskip

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}>{$}r<{$}}
    \{l_1: T_1, \; \dots \; l_n: T_n, \; \dots \; T_k\} \in \{l: T\} \iff l_n = l \wedge T_{n} = T & (1 \leq n \leq k)\\
    X^{Traits} \in \{l: T\} \implies \{l: T\} \in Traits\\
\end{tabular}}

\section{Unnamed Section}

Accessors are constructs that allow reading and writing to fields within a record.

In their most basic form, they consist of a single label ($\#l$).
In this state, an accessor creates a link to a specific field of a record, allowing it to be read from and written to directly.

One of the features that make accessors powerful is the fact that they can operate of different types of records.

In the following example, the same accessor (\texttt{\#age}) is used on two different data types.

\begin{lstlisting}
  get #age {name: "John", age: 35}
  // Getting the age of a person
  get #age {type: "red", age: 12}
  // Getting the age of wine
\end{lstlisting}

This is possible because accessors create a loose restriction on the record they access.
Instead of requiring a specific type, they only require that the record conform to a trait.
In the example above, the only requirement made by the \texttt{\#age} accessor is that the record contain the field \texttt{age}.

\medskip

Another feature of accessors is their ability to be ``stacked''.
With this, it is easy to access arbitratily deep nested records.

In the example below, a stacked accessor is used to modify the street number of a record inside another record.

\begin{lstlisting}
  let address = {street: "Infinite Loop", number: 1}
  let company = {name: "Apple Inc", headquarters: address}

  set #headquarters.number 4 company
\end{lstlisting}

Stacked accessors, like their non-stacked brethren, also create the smallest restriction possible on its type.
In the case above, the expression \texttt{\#headquarters.number} specifies that the accessed record must have a field with the label \texttt{headquarters}.

It also specifies that this field is a record that, in turn, has a field with the label \texttt{number}.
Furthermore, the fact that we are using the \texttt{set} function with an integer argument \texttt{4} tells us that the value associated with the label \texttt{number} is an integer.

\medskip

Besides stacking, it is also possible to join accessors.
Joined accessors operate on different fields of the same record.
The values are treated as tuples, both for setting new values and for getting the current values.

Below is a simple example of accessing the fields \texttt{width} and \texttt{height} in a record.

\begin{lstlisting}
  get #(#width, #height) {width: 40, height: 30}
  // Returns (40, 30)
  set #(#width, #height) (60, 20) {width: 40, height: 30}
  // Returns {width: 60, height: 20}
\end{lstlisting}

Joined accessors create multiple restrictions on the record they access.
In the case above, the record is required to have both fields \texttt{width} and \texttt{height} (and, because of the \texttt{set} argument, we know these fields are integers).

When setting, joined accessors are ``applied'' from left to right.
This means that, if multiple components of the accessor refer to the same field, the last component is used.

\begin{lstlisting}
  set #(#width, #width) (60, 20) {width: 40, height: 30}
  // Returns {width: 20, height: 30}
\end{lstlisting}

\medskip

It is possible to ``distort'' accessors, defining ``getter'' and ``setter'' functions to be applied on the values.
These functions allow a value to be stored in a different format (or even type) than the one used when operating on it.

\begin{lstlisting}
  let ctoF x = x * 9 / 5 + 32;
  let ftoC x = (x - 32) * 5 / 9;

  let fahrenheit = #celsius [ctoF, ftoC];

  get fahrenheit {celsius: 30}
  // Returns 86
\end{lstlisting}

This distortion, combined with joined accessors, allows very powerful and expressive operations.
In the example below, we define a custom accessor to return the area of a record.

\begin{lstlisting}
  let tupleToArea (x, y) = x + y;
  let areaToTuple a = (a, 1);

  let area = #(#width, #height) [tupleToArea, areaToTuple];

  get area {width: 40, height: 30}
  // Returns 1200
\end{lstlisting}

\section{Evaluation}

{\setlength\tabcolsep{8pt}
\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}>{$}r<{$}}
env &::= &\{\} \; | \; \{x \rightarrow v\} \cup env\\
  \\
v &::= &n\\
  &| &raise\\
  &| &(v_1, \; \dots \; v_n) & (n\geq2)\\
  &| &\{l_1: v_1, \; \dots \; l_n: v_n\} & (n\geq1)\\
  &| &\left\langle p, e, env\right\rangle\\
  &| &\#path\\
  \\
path &::= &l\\
  &| &path_1 \; . \; path_2\\
  &| &(path_1, \; \dots \; path_n) & (n\geq2)\\
  &| &path \; [v_1, \; v_2] \\
  \\
\end{tabular}}

\subsection{Pattern Matching}

\infax[]
    {match(x, v) = true, \{x \rightarrow v\}}

\infax[]
    {match(\_, v) = true, \{\}}

\infrule[]
    {\left\|n_1\right\|=\left\|n_2\right\|}
    {match(n_1, n_2) = true, \{\}}

\infrule[]
    {\left\|n_1\right\|\neq\left\|n_2\right\|}
    {match(n_1, n_2) = false, \{\}}

\infrule[]
    {\exists \; i \in \left[1, n\right] \; \; match(p_i, v_i) = false, env_i}
    {match((p_1, ... p_n), (v_1, ... v_n)) = false, \{\}}

\infrule[]
    {\forall \; i \in \left[1, n\right] \; \; match(p_i, v_i) = true, env_i}
    {match((p_1, ... p_n), (v_1, ... v_n)) = true, \displaystyle\bigcup_{i=1}^{n} env_i}

\infrule[]
{k \geq n \andalso \exists \; i \in \left[1, n\right]  \; \; \exists \; j \in \left[1, k\right] \; \; l^1_i = l^2_j \wedge match(p_i, v_j) = false, env_i}
    {match(\{l_1^1: p_1, \dots, l^1_n: p_n, \dots\}, \{l^2_1: v_1, ... l^2_k: v_k\}) = false, \{\}}

\infrule[]
{k \geq n \andalso \forall \; i \in \left[1, n\right]  \; \; \exists \; j \in \left[1, k\right] \; \; l^1_i = l^2_j \wedge match(p_i, v_j) = true, env_i}
    {match(\{l_1^1: p_1, \dots, l^1_n: p_n, \dots\}, \{l^2_1: v_1, ... l^2_k: v_k\}) = true, \displaystyle \bigcup_{i=1}^{n} env_i}


\infrule[]
    {\exists \; i \in \left[1, n\right]\; \; l^1_i = l^2_i \wedge match(p_i, v_i) = false, env_i}
    {match(\{l_1^1: p_1, \dots, l^1_n: p_n\}, \{l^2_1: v_1, ... l^2_n: v_n\}) = false, \{\}}

\infrule[]
    {\forall \; i \in \left[1, n\right] \; \;
      l^1_i = l^2_i \wedge match(p_i, v_i) = true, env_i}
    {match(\{l_1^1: p_1, \dots, l^1_n: p_n\}, \{l^2_1: v_1, ... l^2_n: v_n\}) = true,  \displaystyle \bigcup_{i=1}^{n} env_i}

\subsection{Path Evaluation Rules}

\infax[BS-Label]
    {\mbox{env} \vdash l \Downarrow l}

\infrule[BS-Stacked]
    {\mbox{env} \vdash path_1 \Downarrow path_1' \andalso \mbox{env} \vdash path_2 \Downarrow path_2'}
    {\mbox{env} \vdash path_1 \; . \; path_2 \Downarrow path_1' \; . \; path_2'}

\infrule[BS-Joined]
    {\forall \; k \in \left[1, n\right] \; \; \mbox{env} \vdash e_k \Downarrow \#path_k}
    {\mbox{env} \vdash (e_1, \; \dots \; e_n) \Downarrow (path_1, \; \dots \; path_n)}

\infrule[BS-Distorted]
    {\mbox{env} \vdash path_1 \Downarrow path' \andalso \mbox{env} \vdash e_1 \Downarrow v_1 \andalso \mbox{env} \vdash e_2 \Downarrow v_2}
    {\mbox{env} \vdash path \; [e_1, \; e_2] \Downarrow path \; [v_1, \; v_2]}


\subsection{Path Traversing Rules}

\infrule[]
    {1 \leq \left\|k\right\| \leq \left\|n\right\|\\
    r = \{l_1: v_1, \; \dots \; l_k: v, \; \ldots \; l_n: v_n\}}
    {traverse(l_k, \{l_1: v_1, ... l_n: v_n\}, v) = v_k, r}

\infrule[]
    {traverse(path_1, \{l_1: v_1, ... l_n: v_n\}, v') = rec, r'\\
    traverse(path_2, rec, v) = v', rec'}
    {traverse(path_1 \; . \; path_2, \{l_1: v_1, ... l_n: v_n\}, v) = v', r'}

\infrule[]
    {\{\} \vdash v_2 \; v \Downarrow v' \andalso traverse(path, \{l_1: v_1, ... l_n: v_n\}, v') = v'', r\\
    \{\} \vdash v_1 \; v'' \Downarrow v'''}
    {traverse(path [v_1, \; v_2], \{l_1: v_1, ... l_n: v_n\}, v) = v''', r}

\infrule[]
    {r_0 = \{l_1: v_1, ... l_n: v_n\}\\
    \forall i \in [1, \; n] \; . \; traverse(path_i, r_{i-1}, v_i) = v'_i, r_i}
    {traverse((path_1, \; \dots \; path_n), \{l_1: v_1, ... l_n: v_n\}, (v_1, \; \dots \; v_n)) = (v'_1, \; \dots \; v'_n), r_n}

\subsection{Big-Step Rules}

\infax[BS-Num]
    {\mbox{env} \vdash n \Downarrow n}

\infax[BS-Access]
    {\mbox{env} \vdash \#path \Downarrow \#path}

\infrule[BS-Ident]
    {\mbox{env}(x) = v}
    {\mbox{env} \vdash x \Downarrow v}

\infrule[BS-Tuple]
    {\forall \; k \in \left[1, n\right] \; \; \mbox{env} \vdash e_k \Downarrow v_k}
    {\mbox{env} \vdash (e_1, \; \dots \; e_n) \Downarrow (v_1, \; \dots \; e_n)}

\paragraph{Records}
A record construction expression $\{l_1: e_1, \; \dots \; l_n: e_n\}$ evaluates each of its sub-expressions individually, resulting in a record value.

\infrule[BS-Record]
    {\forall \; k \in \left[1, n\right] \; \; \mbox{env} \vdash e_k \Downarrow v_k}
    {\mbox{env} \vdash \{l_1: e_1, \; \dots \; l_n: e_n\} \Downarrow \{l_1: v_1, \; \dots \; l_n: v_n\}}

\infrule[BS-Get]
    {\mbox{env} \vdash e_1 \Downarrow \#path \andalso \mbox{env} \vdash e_2 \Downarrow \{l_1: v_1, \; \dots \; l_n: v_n\}\\
    traverse(path, e_2, v) = v', r'}
    {\mbox{env} \vdash get \; e_1 \; e_2 \Downarrow v'}

\infrule[BS-Set]
    {\mbox{env} \vdash e_1 \Downarrow \#path \andalso \mbox{env} \vdash e_2 \Downarrow v \andalso \mbox{env} \vdash e_3 \Downarrow \{l_1: v_1, \; \dots \; l_n: v_n\}\\
    traverse(path, e_2, v) = v', r'}
    {\mbox{env} \vdash set \; e_1 \; e_2 \; e_3 \Downarrow r'}

\infrule[BS-Distort]
    {\mbox{env} \vdash e_1 \Downarrow \#path \andalso \mbox{env} \vdash v_1 \Downarrow v \andalso \mbox{env} \vdash e_3 \Downarrow v_2}
    {\mbox{env} \vdash distort \; e_1 \; e_2 \; e_3 \Downarrow \#path [v_1 \; v_2]}

\infrule[BS-Stack]
    {\mbox{env} \vdash e_1 \Downarrow \#path_1 \andalso \mbox{env} \vdash e_2 \Downarrow \#path_2}
    {\mbox{env} \vdash stack \; e_1 \; e_2 \Downarrow \#path_1 \; . \; path_2}



\paragraph{Function Expressions}

\infax[BS-Fn]
    {\mbox{env} \vdash \texttt{fn} \; p \Rightarrow e \Downarrow \left\langle p, e, env\right\rangle}

\paragraph{Application}
An application expression requires either a closure or a recursive closure for its left-hand operand.
The right-hand operand (argument) is always evaluated using the current environment, resulting in a value $v_2$.
\smallskip

In the case of a simple closure, the body of the function ($e$) is evaluated using the stored closure, matching the parameter pattern ($p$) with the argument ($v_2$).

\infrule[BS-AppFn]
    {\mbox{env} \vdash e_1 \Downarrow \left\langle p, e, env\right\rangle \andalso \mbox{env} \vdash e_2 \Downarrow v_2\\
    match(p, v_2) = true, env_1\\
    env_1 \cup \mbox{env} \vdash e \Downarrow v}
    {\mbox{env} \vdash e_1 \; e_2 \Downarrow v}

\infrule[BS-AppFn2]
    {\mbox{env} \vdash e_1 \Downarrow \left\langle p, e, env\right\rangle \andalso \mbox{env} \vdash e_2 \Downarrow v_2\\
    match(p, v_2) = false, env_1}
    {\mbox{env} \vdash e_1 \; e_2 \Downarrow raise}

\paragraph{Let Expressions}
These expressions are used to associate an identifier with a specific value, allowing the value to be reused throughout the program.
Since $V$ is a functional language, these are not variables, and the values assigned to an identifier will be constant (unless the same identifier is used in a new $let$ expression).

After evaluating the expression that is to be associated to the identifier (that is, $e_1$), resulting in $v$, the $let$ expression evaluates $e_2$.
For this evaluation, the association of $p$ to $v$ is added to the environment.
The result of this evaluation (that is, $v_2$) is the final result of the evaluation of the entire $let$ expression.

\infrule[BS-Let]
    {\mbox{env} \vdash e_1 \Downarrow v \andalso match(p, v) = true, env_1 \\
     env_1 \cup \mbox{env} \vdash e_2 \Downarrow v_2}
    {\mbox{env} \vdash \texttt{let} \; p = e_1 \; \texttt{in} \; e_2 \Downarrow v_2}

\infrule[BS-Let2]
    {\mbox{env} \vdash e_1 \Downarrow v \andalso match(p, v) = false, env_1}
    {\mbox{env} \vdash \texttt{let} \; p = e_1 \; \texttt{in} \; e_2 \Downarrow raise}

\bigskip

\paragraph{Match Expression}

The match expression receives a input value and a list of $match$, attempting to pattern match against each one.
The first $match$ which returns a positive result is considered valid, and its corresponding expression is evaluted as the result of the whole expression.

If no $match$ returns a positive result, the whole expression evaluates to $raise$.

\medskip

\infrule[BS-Match]
    {\mbox{env} \vdash e \Downarrow v\\
    \exists j \in \left[1..n\right] multiMatch(v, \mbox{env}, match_j) = true, v_j\\
    \forall k \in \left[1..j\right) multiMatch(v, \mbox{env}, match_k) = false, v_k}
    {\mbox{env} \vdash \texttt{match} \; e \; \texttt{with} \; match_1, ... \; match_n \Downarrow v_j}

\infrule[BS-Match2]
    {\mbox{env} \vdash e \Downarrow v \\
    \forall j \in \left[1..n\right] multiMatch(v, \mbox{env}, match_j) = false, v_j}
    {\mbox{env} \vdash \texttt{match} \; e \; \texttt{with} \; match_1, ... \; match_n \Downarrow raise}

\medskip

In order to properly evaluate a match expression, it is necessary to define an auxiliary function, here called $multiMatch$.
This function receives an input value, an environment and a $match$.

If the $match$ has a conditional expression, it must evaluate to $true$ for the match to be considered valid.

\infrule[]
  {match(p, v) = false, env_1}
  {multiMatch(v, \mbox{env}, p \rightarrow e) = false, v}

\infrule[]
  {match(p, v) = true, env_1 \andalso \mbox{env} \cup env_1 \vdash e \Downarrow v_2}
  {multiMatch(v, \mbox{env}, p \rightarrow e) = true, v_2}

\infrule[]
  {match(p, v) = false, env_1}
  {multiMatch(v, \mbox{env}, p \; \mbox{when} \; e_1 \rightarrow e_2) = false, v}

\infrule[]
  {match(p, v) = true, env_1 \andalso \mbox{env} \cup env_1 \vdash e_1 \Downarrow false}
  {multiMatch(v, \mbox{env}, p \; \mbox{when} \; e_1 \rightarrow e_2) = false, v}

\infrule[]
  {match(p, v) = true, env_1 \andalso \mbox{env} \cup env_1 \vdash e_1 \Downarrow true\\
  \mbox{env} \cup env_1 \vdash e_2 \Downarrow v_2}
  {multiMatch(v, \mbox{env}, p \; \mbox{when} \; e_1 \rightarrow e_2) = true, v_2}

\paragraph{Exceptions}

Some programs can be syntactically correct but still violate the semantics of the $V$ language, such as a dividing by zero or trying to access the head of an empty list.
In these scenarios, the expression is evaluated as the $raise$ value.

Besides violation of semantic rules, the only other expression that evaluates to the $raise$ value is the $raise$ expression, using the following rule:

\infax[BS-Raise]
    {\mbox{env} \vdash raise \Downarrow raise}

\section{Type System}

The type inference algorithm is divided into 3 parts:

\begin{enumerate}
  \item Constraint Collection

    Collects constraints (defined below) for types in the program.
    This is a recursive operation, traversing the syntax tree and collecting constraints from the bottom up.

  \item Constraint Unification

    Validates the collected constraints, resulting in a set of type and trait substitutions.
    If the constraints cannot be unified (i.e they are invalid), the type inference algorith ends here.

  \item Unification Application

    Applies the substitutions the the type of the program.
    This guarantees that the result of the type inference is a base type (or variable types if the result is a polymorphic function).
\end{enumerate}

\subsection{Constraint Collection}

Constraints are equations between type expressions, which can have both constant types and variable types.
To infer the type of a program, the type system recursively collects a set of constraints for every subexpression in that program.
This is done in a static way across the expression tree from the nodes to the root, without having to evaluate any of the expressions.
To create a valid set of constraints, the system must contain an environment, built from the root to the nodes, to ensure identifiers are properly typed.

\paragraph{Environment}
Just like the operational semantics, the type system also uses an environment to store information about identifiers.
In this case, the environment maps identifiers to type associations.
These can be either simple associations or universal associations, which are used for polymorphic functions.

\paragraph{Simple Associations}
These associate an identifier with a unique type, which can be either constant or a variable type.
When the association is called, the type is returned as-is, even if it is a variable type.

\paragraph{Universal Associations}
This association, also called a type scheme, stores a type which contains at least one variable type bound by a ``for all'' quantifier ($\forall$).
When called, this association creates a new variable type for each bound variable and returns a new instance of the type scheme.
Universal associations are used exclusively for polymorphic functions.

To create this type of association, the type system must generate a list of ``free variables'' present in the type that is to be universalized.
These are the variable types that are not present in the environment when the identifier is declared.
When these free variables are found, they are universally bound.
This ensures that only those variable types that are unbound in the environment become universally bound in the resulting association.

\paragraph{Environment Application}

If an identifier is bound to a simple association, its value is returned directly from the environment.

If, on the other hand, an identifier is bound to a universal association, some work must be done for the new  type.
For every free variable in the association, a fresh variable type is declared and substituted in the resulting type.

\subsubsection{Pattern Matching Rules}

\infax[]
    {match(x, T) = \{\}, \{x \rightarrow T\}}

\infax[]
    {match(n, T) = \{T = Int\}, \{\}}

\infax[]
    {match(_, T) = \{\}, \{\}}

\infrule[]
    {\forall i \in \left[1, n\right] \; \; X_i \; is \; new \wedge match(p_i, X_i) = c_i, env_i}
    {match((p_1, ... p_n), T) = \{(X_i, ... X_n) = T\} \cup \displaystyle \bigcup_{i=1}^{n} c_i, \displaystyle \bigcup_{i=1}^{n} env_i}

\infrule[]
    {\forall i \in \left[1, n\right] \; \; X_i \; is \; new \wedge match(p_i, X_i) = c_i, env_i \andalso X_0^{\{\{l_i: X_i\}\} \forall i \in \left[1, n\right]}}
    {match(\{l_1: p_1, \dots, l_n: p_n, \dots\}, T) = \{X_0 = T\} \cup \displaystyle \bigcup_{i=1}^{n} c_i, \displaystyle \bigcup_{i=1}^{n} env_i}

\infrule[]
    {\forall i \in \left[1, n\right] \; \; X_i \; is \; new \wedge match(p_i, X_i) = c_i, env_i}
    {match(\{l_1: p_1, \dots, l_n: p_n\}, T) = \{\{l_1: X_1, \dots, l_n: X_n\} = T\} \cup \displaystyle \bigcup_{i=1}^{n} c_i, \displaystyle \bigcup_{i=1}^{n} env_i}

\subsubsection{Path Typing Rules}

\infrule[]
    {X_1 \; is \; new \andalso X_2^{\{\{l: X_1\}\}} \; is \; new}
    {traverse(\Gamma, l) = X_1, \; X_2, \; X_1 \; | \; \{\} }

\infrule[]
    {traverse(\Gamma, path_1) =  IO_1, \; Rec_1, \; Store_1 \; | \; C_1\\
    traverse(\Gamma, path_2) =  IO_2, \; Rec_2, \; Store_2 \; | \; C_2}
    {traverse(\Gamma, path_1 \; . \; path_2) = IO_2, \; Rec_1, \; Store_1 \; | \; C_1 \cup C_2 \cup \{Store_1 = IO_2\}}

\infrule[]
    {traverse(\Gamma, path) = IO, \; Rec, \; Store \; | \; C\\
    \Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso \Gamma \vdash e_2 : T_2 \; | \; C_2\\
    X_{io} \; is \; new \andalso X_{store} \; is \; new\\
    C' = \{T_1 =  X_{store} \rightarrow X_{io}, T_2 = X_{io} \rightarrow  X_{store},  X_{store} = IO\}}
    {traverse(\Gamma, path \; [e_1, \; e_2]) = X_{io}, \; Rec, \; Store \; | \; C \cup C_1 \cup C_2 \cup C'}

\infrule[]
    {T = (X_1, \; \dots \; X_n) \; is \; new \andalso X_{rec} \; is \; new\\
    \forall i \in [1, n] \; . \; \Gamma \vdash e_i : T_i \; | \; C_i\\
    \forall i \in [1, n] \; . C_i' = C \cup \{T_i = \#(X_i \rightarrow X_{rec})\}}
    {traverse(\Gamma, (e_1, \; \dots \; e_n)) = T, \; X_{rec}, \; T \; | \; \displaystyle \bigcup_{i=1}^{n} C_i'}

\subsubsection{Constraint Collection Rules}
Every expression in $V$ has a rule for constraint collection, similar to how every expression has a rule for its semantic evaluation.

\infax[T-Num]
    {\Gamma \vdash n : \mbox{Int} \; | \; \{\}}

\infrule[T-Ident]
    {\Gamma \left(x\right) = T}
    {\Gamma \vdash x : T \; | \; \{\}}

\infrule[T-Tuple]
    {\forall \; k \in \left[1, n\right] \; \; \Gamma \vdash e_k : T_k \; | \; C_k}
    {\Gamma \vdash (e_1, \; \dots \; e_n) : (T_1, \; \dots \; T_n) \; | \; C_1 \cup \cdots C_n }

\infrule[T-Record]
    {\forall \; k \in \left[1, n\right] \; \; \Gamma \vdash e_k : T_k \; | \; C_k}
    {\Gamma \vdash \{l_1: e_1, \; \dots \; l_n: e_n\} : \{l_1: T_1, \; \dots \; l_n: T_n\} \; | \; C_1 \cup \cdots C_n }

\infrule[T-Access]
    {X_1 \; is\; new \andalso traverse(paths, X_1) = IO, Rec, _, C}
    {\Gamma \vdash \#paths : \#(IO \rightarrow Rec) \; | \; \{\}}

\infrule[T-Get]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso \Gamma \vdash e_2 : T_2 \; | \; C_2 \andalso X_1 \; is \; new}
    {\Gamma \vdash get \; e_1 \; e_2 : X_1  \; | \; C_1 \cup C_2 \cup \{T_1 = \#(X_1 \rightarrow T_2)\}}

\infrule[T-Set]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso \Gamma \vdash e_2 : T_2 \; | \; C_2 \andalso \Gamma \vdash e_3 : T_3 \; | \; C_3}
    {\Gamma \vdash set \; e_1 \; e_2 \; e_3 : T_3  \; | \; C_1 \cup C_2 \cup C_3 \cup \{T_1 = \#(T_2 \rightarrow T_3)\}}

\infrule[T-Stack]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso \Gamma \vdash e_2 : T_2 \; | \; C_2\\
    X_1 \; is\; new \andalso X_2 \; is \; new \andalso X_3 \; is \; new}
    {\Gamma \vdash stack \; e_1 \; e_2 : \#(X_3 \rightarrow X_2) \; | \; C_1 \cup C_2 \cup \{T_1 = \#(X_1 \rightarrow X_2), T_2 = \#(X_3 \rightarrow X_1)\}}

\infrule[T-Distort]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso \Gamma \vdash e_2 : T_2 \; | \; C_2 \andalso \Gamma \vdash e_3 : T_3 \; | \; C_3\\
    X_1 \; is\; new \andalso X_2 \; is \; new \andalso X_3 \; is \; new}
    {\Gamma \vdash distort \; e_1 \; e_2 \; e_3 : \#(X_3 \rightarrow X_2)  \; | \; C_1 \cup C_2 \cup C_3 \cup \{T_1 = \#(X_1 \rightarrow X_2), T_2 = X_1 \rightarrow X_3, T_3 = X_3 \rightarrow X_1\}}

\infrule[T-App]
    {\Gamma \vdash e_1 : T_1 \; | \; C_1 \andalso \Gamma \vdash e_2 : T_2 \; | \; C_2  \andalso X_1 \; is \; new}
    {\Gamma \vdash e_1 \; e_2 : X \; | \; C_1 \cup C_2 \cup \{T1 = T_2 \rightarrow X_1\}}

\infrule[T-Fn]
    {X \; is \; new \andalso match(p, X) = C, env \andalso env \cup \Gamma \vdash e : T_1 \; | \; C_1}
    {\Gamma \vdash \texttt{fn} \; p \Rightarrow e : X \rightarrow T_1 \; | \; C \cup C_1}

\infrule[T-Match]
    {\Gamma \vdash e : T \; | \; C \andalso X_1 \; is \; new\\
    \forall j \in \left[1..n\right] multiMatch(T, X_1, \Gamma, match_j) = C_j}
    {\Gamma \vdash \texttt{match} \; e \; \texttt{with} \; match_1, ... \; match_n : X_1 \; | \; C \cup \displaystyle \bigcup_{i=1}^{n} C_i}

\infrule[]
  {match(p, T_1) = C, \Gamma_1 \andalso \Gamma_1 \cup \Gamma \vdash e : T_3 \; | \; C_3}
  {multiMatch(T_1, T_2, \Gamma, p \rightarrow e) = C \cup C_3 \cup \{T_3 = T_2\}}

\infrule[]
  {match(p, T_1) = C, \Gamma_1 \andalso \Gamma_1 \cup \Gamma \vdash e_1 : T_3 \; | \; C_3 \andalso \Gamma_1 \cup \Gamma \vdash e_2 : T_4 \; | \; C_4}
  {multiMatch(T_1, T_2, \Gamma, p \; \mbox{when} \; e_1 \rightarrow e_2) = C \cup C_3 \cup C_4 \cup \{T_3 = Bool, T_4 = T_2}

\infrule[T-Raise]
    {X_1 \; is\; new}
    {\Gamma \vdash raise : X_1 \; | \; \{\}}

The constraint collection rule for \texttt{let} is a little more complicated, as it envolves calling the type inference algorithm recursively.
The steps to collect constraints for a expression $\texttt{let} \; p = e_1 \; \texttt{in} \; e_2$ are as follow:

\begin{enumerate}
  \item $\Gamma \vdash e_1 : T_1 \; | \; C_1$

  \item $\texttt{unify}(C_1) = \sigma_1, \theta_1$

  \item $\texttt{apply}(\sigma_1, \theta_1, T_1) = T'_1$

  \item $\texttt{apply}(\sigma_1, \theta_1, \Gamma) = \Gamma'$

  \item $\texttt{freeVars}(T'_1, \Gamma') = free$

  \item $\texttt{if} free = \varnothing \texttt{then}$

  \begin{enumerate}
    \item $match(p, T_1) = C, env$
  \end{enumerate}

  \item \texttt{else}

  \begin{enumerate}
    \item $C = \varnothing$
    \item $env = \Gamma \cup \{x \rightarrow \forall X \in free \; . \; T'_1 \}$
  \end{enumerate}

  \item $env \cup \Gamma \vdash e_2 : T_2 \; | \; C_2$

  \item return $T_2 \; | \; C \cup C_1 \cup C_2$

\end{enumerate}

\subsection{Constraint Unification}

The unification algorithm recursively iterates through the list of constraints, matching

\infax[]
    {\texttt{unify}(\varnothing) = \varnothing, \varnothing}

\infrule[]
    {T_1 = T_2}
    {\texttt{unify}(\{T_1 = T_2\} \cup C) = \texttt{unify}(C)}

\infrule[]
    {T_1 = T_1^1 \rightarrow T^1_2 \andalso T_2 = T_1^2 \rightarrow T_2^2}
    {\texttt{unify}(\{T_1 = T_2\} \cup C) = \texttt{unify}(C \cup \{T_1^1 = T_1^2, T_2^1 = T_2^2\})}

\infrule[]
    {T_1 = (T^1_1, \; \dots \; T^1_n) \andalso T_2 = (T^2_1, \; \dots \; T^2_n)}
    {\texttt{unify}(\{T_1 = T_2\} \cup C) = \texttt{unify}(C \cup \{T^1_1 = T^2_1, \; \dots \; T^1_n = T^2_n\})}

\infrule[]
    {T_1 = \{l_1: T^1_1, \; \dots \; l_n: T^1_n\} \andalso T_2 = \{l_1: T^2_1, \; \dots \; l_n: T^2_n\}}
    {\texttt{unify}(\{T_1 = T_2\} \cup C) = \texttt{unify}(C \cup \{T^1_1 = T^2_1, \; \dots \; T^1_n = T^2_n\})}

\infrule[]
    {T_1 = X^{tr} \andalso X \notin \texttt{freeVars}(T_2, \varnothing)\\
    T_2 \in tr \andalso C' = [X \rightarrow T_2]C}
    {\texttt{unify}(\{T_1 = T_2\} \cup C) = \texttt{unify}(C')}

\infrule[]
    {T_2 = X^{tr} \andalso X \notin \texttt{freeVars}(T_1, \varnothing)\\
    T_1 \in tr \andalso C' = [X \rightarrow T_1]C}
    {\texttt{unify}(\{T_1 = T_2\} \cup C') = \texttt{unify}(C' \cup \{T'_1 = T'_2, T''_1 = T''_2\})}
\end{document}
